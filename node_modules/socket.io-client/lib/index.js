
/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  // 1、假设 uri 为 "http://localhost:3000"，则 source === "http://localhost:3000"
  // 2、假设 uri 为 "http://localhost:3000/test"，则 source === "http://localhost:3000/test"
  var source = parsed.source;
  
  // id 的规则为 protocol + host + port，也就是说，跟 path 无关
  // 1、假设 uri 为 "http://localhost:3000"，则 id === "http://localhost:3000"
  // 2、假设 uri 为 "http://localhost:3000/test"，则 id === "http://localhost:3000"
  var id = parsed.id;
  
  // 这里的path其实是namespace的范畴（namespace)，根据 uri 来判断，跟 opts.path 无关
  // 1、io('http://localhost:8080/test')，则 parsed.path === '/test'。
  // 2、io('http://localhost:8080', {path: '/test'})，则 parsed.path === '/'。
  var path = parsed.path;
  
  // 是否相同的命名空间（冲突）。需要同时满足两个条件
  // 1、cache[id] 存在：比如连续两次调用 io('http://localhost:3000')，那么第二次调用时，cache[id]存在
  // 2、path in cache[id].nsps：也就是说，当前连接的命名空间，跟前面连接已存在的命名空间之一相同。
  var sameNamespace = cache[id] && path in cache[id].nsps;
  
  // 大部分情况下，可以复用旧连接，除了以下两种情况
  // 1、选择一：通过配置 opts.forceNew、opts['force new connection']、opts.multiplex 强制使用新连接
  // 2、选择二：sameNamespace === true，使用新连接
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) { // newConnection 为 true，则新开连接
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else { // 可复用旧连接
    if (!cache[id]) { // 如果 id 对应的连接不存在，先创建一个
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  // manager = cache[id] = new Manage(source, opts);
  // io('http://localhost:3000/nsp1', opts) ==> manager.socket('/nsp1', opts)
  // io('http://localhost:3000/nsp2', opts) ==> manager.socket('/nsp2', opts)
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');
